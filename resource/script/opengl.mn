
var shaderStr = 
"
    uniform   mat4 MATRIX_MVP;
    uniform sampler2D TEXTURE_0;
    
    varying   vec2 v_tex;

    #ifdef VERTEX_SHADER
    
    attribute vec4 pos;
    attribute vec2 tex;
    
    void main()
    {
       gl_Position = MATRIX_MVP * pos;
       v_tex = tex;
    }
    
    #endif
    
    #ifdef FRAGMENT_SHADER
    #ifdef GL_ES
    precision mediump float;
    #endif
    
    void main()
    {
       gl_FragColor = texture2D( TEXTURE_0, v_tex );
    }
    
    #endif
";

var programID = GL.LoadProgram(shaderStr);
GL.BindAttribLocation(programID, 0, "pos");
GL.BindAttribLocation(programID, 1, "tex");
GL.EnableVertexAttribArray(0);
GL.EnableVertexAttribArray(1);
GL.LinkProgram(programID);
GL.UseProgram(programID);
GL.Viewport(0, 0, 320, 480);

var texLoc = GL.GetUniformLocation(programID, "TEXTURE_0");
var mvpLoc = GL.GetUniformLocation(programID, "MATRIX_MVP");

var modelMat    = mat4.new();
var viewProjMat = mat4.new();
viewProjMat.ortho(0, 320, 0, 480, -100, 1000);

var cache = {};
var loadImage = func(path, x, y, width, height)
{
	var tex = cache[path];
	if (tex == null)
	{
		tex = ::GL.LoadTexture(path);
		cache.insert(path, tex);
		::print(tex.id);
	}
	var image = 
	{
		tex : tex,
		x : x,
		y : y,
		w : width,
		h : height,
		draw : func(width, height, posx, posy)
		{
			modelMat.transform(width,height,1, 0,0,0,1, posx, posy,0);
			modelMat.mult(viewProjMat);
			::GL.BindTexture(texLoc, tex.id);
			::GL.UniformMatrix(mvpLoc, modelMat);
			::GL.DrawRegion(tex.id, tex.width, tex.height, x, y, w, h);
		}
	};
	return image;
};

::insert("LoadImage", loadImage);