

var shaderStr = 
"
    uniform   mat4 MATRIX_MVP;
    uniform sampler2D TEXTURE_0;
    
    varying   vec2 v_tex;

    #ifdef VERTEX_SHADER
    
    attribute vec4 pos;
    attribute vec2 tex;
    
    void main()
    {
       gl_Position = MATRIX_MVP * pos;
       v_tex = tex;
    }
    
    #endif
    
    #ifdef FRAGMENT_SHADER
    #ifdef GL_ES
    precision mediump float;
    #endif
    
    void main()
    {
       gl_FragColor = texture2D( TEXTURE_0, v_tex );
    }
    
    #endif
";

var programID = GL.LoadProgram(shaderStr);
GL.BindAttribLocation(programID, 0, "pos");
GL.BindAttribLocation(programID, 1, "tex");
GL.EnableVertexAttribArray(0);
GL.EnableVertexAttribArray(1);
GL.LinkProgram(programID);
GL.UseProgram(programID);

var texLoc = GL.GetUniformLocation(programID, "TEXTURE_0");
var mvpLoc = GL.GetUniformLocation(programID, "MATRIX_MVP");

var mat = ::alloc(4*16);
GL.LoadIdentity();
GL.Ortho(-160, 160, -240, 240, -100, 1000);
GL.MatrixMode(GL.MODELVIEW);
GL.GetFloatv(GL.MODELVIEW_MATRIX, mat);
GL.UniformMatrix(mvpLoc, mat);
GL.Viewport(-100, -100, 320, 480);

var tex = GL.LoadTexture("../resource/texture/test.png");
GL.BindTexture(texLoc, tex.id);
print("tex.id: ",tex.id);
print("tex.w: ",tex.width);
print("tex.h: ",tex.height);


var posx = 0, posy = 0;
var displayCallback = func()
{
  GL.DrawRegion(tex.id, tex.width, tex.height, posx, posy, tex.width, tex.height);
};

var inputCallback = func (state, x, y)
{
	::print("state: " + state + ", x: " + x + ", y: " + y);
	posx = x;
	posy = y;
	::GL.ClearColor(1,x/320.0,y/480.0,1);
	::GL.Clear(true);
};

var idleCallback = func()
{
	//::print("idle");
};

::insert("displayCallback", displayCallback);
::insert("inputCallback", inputCallback);
::insert("idleCallback", idleCallback);
