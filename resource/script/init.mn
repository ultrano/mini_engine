var shaderStr = 
"
    uniform   mat4 MATRIX_MVP;
    uniform sampler2D TEXTURE_0;
    
    varying   vec2 v_tex;

    #ifdef VERTEX_SHADER
    
    attribute vec4 pos;
    attribute vec2 tex;
    
    void main()
    {
       gl_Position = MATRIX_MVP * pos;
       v_tex = tex;
    }
    
    #endif
    
    #ifdef FRAGMENT_SHADER
    #ifdef GL_ES
    precision mediump float;
    #endif
    
    void main()
    {
       gl_FragColor = texture2D( TEXTURE_0, v_tex );
    }
    
    #endif
";

class Shader
{
	var m_programID;
	var m_uniforms;
	var m_attribs;
	constructor(source)
	{
		if (::typeof(source) != "string") return;
		m_programID = ::GL.LoadProgram(source);
		m_uniforms  = ::GL.GetActiveUniforms(m_programID);
		m_attribs   = ::GL.GetActiveAttribs(m_programID);
	};
	func getUniformLocation(name)
	{
		if (m_uniforms.has(name) == false) return null;
		return m_uniforms[name];
	};
	func getAttribLocation(name)
	{
		if (m_attribs.has(name) == false) return null;
		return m_attribs[name];
	};
};

class Texture
{
	var id;
	var width;
	var height;
};

class Material
{
	constructor(shader)
	{
		m_shader = shader;
		m_values = {};
	};
	func setTexture(name, texture)
	{
		if (::typeof(texture) != ::Texture.type) return;
		var loc = m_shader.getUniformLocation(name);
		if (loc == null) return;
		m_values.insert(loc, texture);
	};
	var m_shader;
	var m_values;
};

var shader = new Shader(shaderStr);
var material = new Material(shader);
var texture = new Texture();

material.setTexture("TEXTURE_0", texture);
material.m_values.iterate(func(k,v){::print(k,v);});

